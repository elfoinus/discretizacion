# -*- coding: utf-8 -*-
"""segunda_parte.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aR08S2wW6WgZLrGU5hBDyTsgBEbz4IhN
"""

import plotly.express as px
from numpy import *


#anchoViga ancho o base de la viga...  en la figura equivale a C
#alturaViga --- en la figura equivale a D o B
#posInicioViga posicion de la viga con respecto a superficieX
#h tama√±o de la cuadricula en el espacio comprendido entre superficieX y superficieY

superficieX = 25
superficieY = 25
posInicioViga = 10
alturaViga = 15 #no puede ser mayor o igual a superficieY
anchoViga = 5   #no puede ser mayor o igual a superficieX
h = 1
H = 4 #h de la ecuacion discretizada

u = zeros((superficieX, superficieY), float)                # arreglo para la funcion corriente  

V0 = 1.0                                            # velocidad inicial

iter = 100   #converge mucho mas rapido ahora vs la primera practica...
result = zeros((superficieY,superficieX ), float)         #arreglo para imprimir u


sistema=[]                                    # matriz que guardara el sistema  de ecuaciones  superficieX^2 * superficieY^2

vectorSolucion = zeros(superficieY*superficieX , float) #guardara la soluciones del sistema anterior para poderlas ir sumando

despeje = zeros(superficieX*superficieY )   #matriz con los valores independientes de las ecuaciones del sistema



def limitesMaya():                                      
    for i in range(0, superficieX):                
       for j in range(0, superficieY):           
            u[i, j] = j * V0
    for i in range(0, superficieX ):               
      u[i, superficieY-1] = u[i, superficieY-2] + V0*h
    for j in range(0, superficieY):
        u[1, j] = u[0, j]                        
    for  i in range(0, superficieX):                
       if i <=  posInicioViga and i>= posInicioViga+anchoViga:
           u[i, 0] = 0.
    for j in range(1, superficieY ):                    
        u[superficieX-1, j] = u[superficieX-2, j]  


def viga(): 
   for i in range(posInicioViga, posInicioViga+anchoViga+1): 
     for j in range(0, alturaViga+1):  
         u[i,j] =0; #llenamos en 0 la region de la viga para simular el obstaculo

#retorna el entero correspondiente a la posicion cuando i y j son iguales... al recorrer la superficie
def posicion(i,j):
  n=0
  for y in range(0,superficieY):
    for x in range(0,superficieX):
      if y==i and x==j:
        return n
      else:
        n=n+1

#sistema de ecuaciones 
def ecuaciones():
  ecuaciones = [];
  for i in range(superficieY):
    for j in range(superficieX):
      ecuacion= zeros(superficieX*superficieY)
     
      if i < superficieY-1:
          ecuacion[posicion(i+1,j)]=(1-H/2)
      if i > 0:
          ecuacion[posicion(i-1,j)]=(1-H/2) 
      if j < superficieX-1:
          ecuacion[posicion(i,j+1)]=(1-H/2)
      if j > 0:
          ecuacion[posicion(i,j-1)]=(1-H/2) 

      ecuacion[posicion(i,j)]=-4 #llena de 4 la posicion (0,0) , (1,1) , (2,2) ,..., (n,n)
      ecuaciones.append(ecuacion)

  temporal= zeros((superficieY*superficieY,superficieX*superficieX))
  for i in range(0,superficieY*superficieY):
    for j in range(0,superficieX*superficieX):
      temporal[i,j]=ecuaciones[i][j]
  return temporal

sistema = ecuaciones()

#establece limites de la maya
limitesMaya()
n = 0;

#iteramos
viga()  #establecemos la viga

#establecemos las condiciones iniciales con los terminos independientes
for i in range(0,superficieY):
  for j in range(0,superficieX):
    despeje[posicion(i,j)]=u[i,j]

error = 0
while (n < iter ):
    n +=  1
    suma=0
    # relajacion por ... metodo de gauss-seidel
    # https://www.youtube.com/watch?v=SuguUYdE67A&t
    # https://www.youtube.com/watch?v=i8der7TzYp0

    for i in range( 0,superficieY*superficieY ):
      suma=0
      for j in range(0,superficieX*superficieX):
        if j != i :
            suma = suma + sistema[i,j] * vectorSolucion[j] 

      vectorSolucion[i] = abs ( (despeje[i]-suma) / sistema[i,i] ) #solo se tiene en cuenta la diagonal "dominante" para no realizar pivoteo parcial  sistema[i,i]
      

    if n%1 ==  0 : 
      print (n)
      #print(error)
      nn = 0
      for  j in range(0, superficieY):
          for  i in range(0, superficieX ):
            result[i][j] = vectorSolucion[nn]
            nn=nn+1
      
      fig = px.imshow(result[::-1])
      #fig = px.imshow(result)
      #fig = px.imshow(u)
      fig.show()
      #fig = px.imshow(w)
      #fig.show()
      
    
    #relajacion()